1. 已經建立了新的 images 資料表
2. 以下為新增的表使用的 DDL：
```Object:  Table [dbo].[Images] 
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Images](
	[ImageId] [bigint] IDENTITY(1,1) NOT NULL,
	[ImageGuid] [uniqueidentifier] NOT NULL,
	[EntityType] [nvarchar](50) NOT NULL,
	[EntityId] [int] NOT NULL,
	[Category] [nvarchar](50) NOT NULL,
	[MimeType] [nvarchar](50) NOT NULL,
	[OriginalFileName] [nvarchar](255) NOT NULL,
	[StoredFileName]  AS (lower(CONVERT([char](36),[ImageGuid]))+case [MimeType] when 'image/webp' then '.webp' when 'image/jpeg' then '.jpg' when 'image/png' then '.png' else '.bin' end) PERSISTED NOT NULL,
	[FileSizeBytes] [bigint] NOT NULL,
	[Width] [int] NOT NULL,
	[Height] [int] NOT NULL,
	[DisplayOrder] [int] NULL,
	[IsActive] [bit] NOT NULL,
	[UploadedByUserId] [uniqueidentifier] NULL,
	[UploadedAt] [datetime2](7) NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[ImageId] ASC
)WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Images_ImageGuid] UNIQUE NONCLUSTERED 
(
	[ImageGuid] ASC
)WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

ALTER TABLE [dbo].[Images] ADD  DEFAULT (newsequentialid()) FOR [ImageGuid]
GO

ALTER TABLE [dbo].[Images] ADD  DEFAULT ((1)) FOR [IsActive]
GO

ALTER TABLE [dbo].[Images] ADD  DEFAULT (getutcdate()) FOR [UploadedAt]
GO

ALTER TABLE [dbo].[Images]  WITH CHECK ADD  CONSTRAINT [CK_Images_Category] CHECK  (([Category]='Product' OR [Category]='Gallery' OR [Category]='Avatar' OR [Category]='Balcony' OR [Category]='Living' OR [Category]='Kitchen' OR [Category]='BedRoom'))
GO

ALTER TABLE [dbo].[Images] CHECK CONSTRAINT [CK_Images_Category]
GO

ALTER TABLE [dbo].[Images]  WITH CHECK ADD  CONSTRAINT [CK_Images_EntityType] CHECK  (([EntityType]='Announcement' OR [EntityType]='Furniture' OR [EntityType]='Property' OR [EntityType]='Member'))
GO

ALTER TABLE [dbo].[Images] CHECK CONSTRAINT [CK_Images_EntityType]
GO

EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'圖片表' , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'TABLE',@level1name=N'Images'
GO
```

3. 命名邏輯：
- EntityType 用來辨識「主實體」：Property、Member、Furniture … 等；
- Category 專注在「該實體內部的子分類」：BedRoom、LivingRoom、Kitchen …；
  - 預計為已程式碼編寫，供使用者以下拉選單選擇；
- 把 Category 做成 ENUM，以避免前端任意輸入導致大小寫或空格差異；
- 把 Category 依 EntityType 過濾後回傳（例如只給 Property 類型的選項）；



4. URL 欄位會重複存「https://…/」字首，資料量大時可考慮改存相對路徑 (/images/...) 再由程式組完整網址，節省空間並方便換域名。

5. Entity Framework Core
要新增 Image entity + DbSet<Image>，並執行 Add-Migration / Update-Database。
所有使用圖片的 Service / Repository 應改為依 EntityType + EntityId 查詢。

6. CASCADE / 軟刪除策略
建議不要對 (EntityType, EntityId) 加 FK，改用 應用程式端級聯。
若主資料刪除，請在 Service 層將對應 Image IsActive = 0，並排定背景批次真正刪檔。

7. 測試、Seeding、Mock Data
RealDataSeeder、單元測試需更新。
整合測試裡凡是直接查 PropertyImages 的 LINQ 需調整。

8. 資料搬遷
若要移除舊表，需寫腳本把舊資料 insert into Images 並重寫 URL/欄位。
期間可用 View 或 Stored Procedure 讓舊程式碼仍可查到資料。

9. 對 FileSizeBytes、Width/Height 建立合理驗證，避免惡意上傳超大檔。
加快取用：常見頁面可把縮圖 CDN 化、加快首屏。

10. 為防未來再次改動，封裝一個 IImageRepository + IImageService，上層只依 interface，不直接 query Images 表。
11. 在 Migration 前備份 DB，並在 Staging 完整跑一輪上傳 / 瀏覽 / 刪除流程確認一切正常。

12. 只存 GUID，然後在應用程式層組裝各尺寸的 URL。因為路徑結構是固定的 (images/{category}/{entityId}/{size}/{guid}.webp)，有了 Category, EntityId, StoredFileName，應用程式完全可以推導出所有尺寸的 URL。這將極大減少 Images 表的寬度

13. 高併發上傳時，為避免 IX_Images_UniqueDisplayOrder 造成的鎖，你可以：
1) 先 INSERT DisplayOrder = NULL，
2) 之後批次計算排序再 UPDATE。

14. 以 EntityType + EntityId 快速抓圖
ImageGuid 唯一且用來當 Blob 檔名

15. 需在程式端準備「MIME→副檔名」對照表，例如
image/webp → .webp、image/jpeg → .jpg、image/png → .png。

16. 若未來頻繁以 ImageGuid 做單筆查詢或 JOIN，可再建：
CREATE NONCLUSTERED INDEX IX_Images_ImageGuid ON dbo.Images(ImageGuid);

17. EntityId 欄位儲存的是實際的 ID 值。
這個 ID 值會由程式（應用層） 在上傳圖片時，根據圖片屬於哪個實體（會員、房源等）來讀取該實體的 ID，然後填入 EntityId 欄位。
當需要查詢時，程式（應用層） 會根據 EntityType 欄位的值，決定去哪張業務實體表（Members、Properties 等）中，使用 EntityId 欄位的值來找到對應的實體記錄。

18. 應用程式負責寫入時的驗證：
  - 當圖片上傳時，ImageUploadService 或其上層的服務（例如 MemberService 或 PropertyService）在將元資料存入 Images 表之前，應該驗證所提供的 EntityId 是否真的存在於對應的 EntityType 表中。這可以在業務邏輯層完成，而不是依靠資料庫。
  - 例如，在保存會員頭像時，先查一下 Members 表，確認 memberId 確實存在。
- 應用程式負責更新和刪除時的級聯操作：
  - 更新：如果業務實體的 ID 發生變化（這種情況相對較少發生），應用程式在更新主表 ID 的同時，必須同步更新 Images 表中所有關聯的 EntityId 欄位。
  - 刪除：當一個業務實體（如會員或房源）被刪除時，應用程式必須主動執行邏輯，找到 Images 表中所有 EntityType 和 EntityId 相符的圖片記錄，先從 Azure Blob Storage 中刪除實際的圖片檔案，然後再從 Images 資料表中刪除這些元資料記錄。這稱為應用程式層的級聯刪除。
- 嚴格的權限管理：
  - 限制對生產資料庫的直接修改權限。只有信任的自動化流程或經過嚴格審核的人員才能直接修改資料，避免在沒有應用程式層驗證的情況下，直接執行資料庫操作。

19. 在資料庫加「計算欄位」StoredFileName，查詢時不用在 C# 手動組字串，可對 StoredFileName 建索引。