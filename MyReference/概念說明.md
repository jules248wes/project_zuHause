# 概念說明

## `AddScoped`：ASP.NET Core 的依賴注入生命週期

### 1. `AddScoped` 是什麼？

`AddScoped` 是 ASP.NET Core 內建的**依賴注入 (Dependency Injection, DI)** 容器中，用於註冊服務並指定其生命週期的方法之一。它告訴 DI 容器，這個被註冊的服務應該以 **「作用域 (Scoped)」** 的生命週期來管理。

### 2. Scoped 生命週期的意義與目的

在 ASP.NET Core 網站應用程式中，一個「作用域」通常等同於一個 **HTTP 請求 (Request) 的完整生命週期**。

#### 運作方式

1.  **請求開始**：當一個新的 HTTP 請求 (例如：使用者訪問某個頁面、呼叫一個 API) 進入伺服器時，DI 容器會為這個請求建立一個全新的、獨立的作用域。
2.  **首次使用**：在這個請求的處理過程中，當程式碼第一次需要用到某個 Scoped 服務時，DI 容器會建立一個該服務的**新實例 (Instance)**。
3.  **重複使用**：在**同一個請求**的後續處理中，無論有多少個不同的地方需要這個服務，DI 容器都會提供**步驟 2 中建立的同一個實例**。
4.  **請求結束**：當伺服器處理完畢這個請求並送出回應後，這個請求的作用域就會被銷毀，同時，所有在這個作用域中建立的服務實例也會被一併銷毀和釋放。

#### 主要目的

-   **資源共享與狀態一致性**：這是 `AddScoped` 最核心的用途。它確保在單次請求的處理鏈中，多個不同的元件（例如 Controller、Service、Repository）能夠共享同一個服務實例。這對於需要共享資料庫連線 (`DbContext`) 或維護請求內狀態一致性的場景至關重要。

-   **資源效率與管理**：避免資源浪費或洩漏。因為服務的生命週期與請求綁定，請求結束後資源會被自動清理（例如，資料庫連線會被歸還到連線池），這是一種高效且安全的資源管理方式。

-   **執行緒安全 (Thread Safety)**：Web 伺服器會同時處理多個不同的 HTTP 請求。由於每個請求都有自己獨立的服務實例，因此可以自然地避免不同請求之間因共享同一個物件而可能產生的執行緒衝突問題。

### 3. `zuHause/Program.cs` 中的應用實例

在 `zuHause` 專案中，`AddScoped` 被廣泛應用於註冊各種核心服務，確保應用程式的穩定與高效。

**實例 1：資料庫上下文 `ZuHauseContext`**

```csharp
// Program.cs
builder.Services.AddDbContext<ZuHauseContext>(
    options => options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"))
);
```

雖然這裡使用的是 `AddDbContext` 擴充方法，但它在底層預設就是將 `ZuHauseContext` 註冊為 **Scoped** 服務。

-   **應用解析**：這項設定確保了在處理單一 API 或頁面請求的整個過程中，所有對資料庫的操作（讀取、寫入、更新）都使用**同一個 `DbContext` 實例**。這對於 Entity Framework Core 的**變更追蹤 (Change Tracking)** 和**交易 (Transactions)** 機制是絕對必要的。如果每個服務都拿到不同的 `DbContext` 實例，那麼在一個請求中對資料的修改將無法被正確追蹤，最終導致儲存失敗或資料不一致。

**實例 2：自訂應用程式服務**

```csharp
// Program.cs

// 註冊圖片處理服務
builder.Services.AddScoped<zuHause.Interfaces.IImageProcessor, zuHause.Services.ImageSharpProcessor>();

// 註冊房源圖片 Facade 服務
builder.Services.AddScoped<zuHause.Interfaces.IPropertyImageService, zuHause.Services.PropertyImageService>();

// 註冊權限檢查服務
builder.Services.AddScoped<zuHause.Services.Interfaces.IPermissionService, zuHause.Services.PermissionService>();
```

-   **應用解析**：
    -   假設有一個 `PropertyController` 的 Action 方法，它需要使用 `IPropertyImageService` 來處理圖片，同時也需要 `IPermissionService` 來檢查權限。
    -   當請求進來時，DI 容器會為這個請求建立一個 `PropertyImageService` 實例和一個 `PermissionService` 實例。
    -   如果 `PropertyImageService` 內部又依賴了 `IImageProcessor`，DI 容器會再建立一個 `ImageSharpProcessor` 實例並注入到 `PropertyImageService` 中。
    -   如果在同一個 Action 方法的後續程式碼中，又直接注入並使用了 `IImageProcessor`，那麼它得到的將會是**先前建立並注入到 `PropertyImageService` 中的同一個 `ImageSharpProcessor` 實例**，而不是一個全新的實例。
    -   這種機制保證了在整個請求處理鏈中，所有相關服務都能共享一致的資源和狀態，避免了不必要的物件建立開銷。

### 4. 何時應該選擇 `AddScoped`？

`AddScoped` 是 ASP.NET Core 應用程式中最常用、也最安全的生命週期選項，特別適用於：

-   **資料庫相關服務**：如 `DbContext` 和所有操作資料庫的 Repository 層服務。
-   **HTTP 相關服務**：如 `IHttpClientFactory` 建立的 `HttpClient`。
-   **需要維護請求內狀態的服務**：例如，一個服務需要在請求開始時計算某些值，並在請求處理過程中供其他元件重複使用。
-   **大部分的業務邏輯服務**：除非一個服務是完全無狀態且建立成本極低（可考慮 `Transient`），或者需要在所有請求間共享（應謹慎使用 `Singleton`），否則 `Scoped` 通常是預設的最佳選擇。

---

## `IQueryable<T>` vs. `List<T>`：延遲執行與立即執行

在與資料庫互動時，理解 `IQueryable<T>` 和 `List<T>` (或 `IEnumerable<T>`) 的根本差異至關重要。這直接影響到應用程式的效能、記憶體使用和資料庫負載。

### 核心概念

| 特性 | `IQueryable<T>` (延遲執行) | `List<T>` (立即執行) |
| :--- | :--- | :--- |
| **本質** | **運算式樹 (Expression Tree)** | **記憶體中的集合 (In-Memory Collection)** |
| **執行時間** | 當結果被「實現」時 (如 `ToList()`, `Count()`, `foreach`) | 當 `ToList()` 或類似方法被呼叫時 |
| **資料來源** | 遠端資料來源，如 SQL 資料庫 | 本地記憶體 |
| **查詢組合** | **可在伺服器端組合**。所有 `Where`, `OrderBy`, `Select` 等操作會被翻譯成最終的 SQL 查詢 | **在客戶端 (應用程式) 執行**。所有資料先載入記憶體，再進行篩選、排序 |
| **效能** | **高效**。只從資料庫拉取必要的資料 | **低效** (若資料量大)。會將整個資料表或大量資料載入記憶體 |

### `AdminController.cs` 中的實戰分析

讓我們以 `FilterLandlords` 方法 (原 `UsersList`，邏輯類似) 為例，深入解析這段程式碼：

```csharp
// AdminController.cs, 行 132-171 (示意)

// 1. 建立 IQueryable
var query = _context.Members
    .Where(m => m.IsLandlord)
    .AsQueryable();

// 2. 動態組合查詢條件 (此時尚未執行任何資料庫查詢)
if (!string.IsNullOrEmpty(keyword))
{
    query = query.Where(m => m.MemberName.Contains(keyword));
}
if (residenceCityID.HasValue)
{
    query = query.Where(m => m.ResidenceCityId == residenceCityID.Value);
}
// ... 其他篩選條件 ...

// 3. 第一次資料庫執行：計算總數
// .Count() 是一個「實現」方法，它會觸發資料庫查詢
// EF Core 會將上面組合的所有 Where 條件翻譯成一條 SQL:
// SELECT COUNT(*) FROM Members WHERE IsLandlord = 1 AND MemberName LIKE '%...%' AND ...
var totalCount = query.Count();

// 4. 第二次資料庫執行：取得分頁後的資料
// .ToList() 是另一個「實現」方法，再次觸發資料庫查詢
// EF Core 會將所有 Where 加上 OrderBy, Skip, Take 翻譯成另一條 SQL:
// SELECT TOP(10) [m_columns]... FROM Members WHERE ... ORDER BY ... OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY
var landlords = query
    .OrderByDescending(m => m.CreatedAt)
    .Skip((page - 1) * pageSize)
    .Take(pageSize)
    .Select(...) // 在伺服器端轉換成需要的格式
    .ToList(); // <<-- 在此執行查詢，結果載入記憶體成為 List<T>
```

#### 程式碼解析

1.  **`var query = ... .AsQueryable();`**
    -   這行程式碼**不會**執行任何資料庫查詢。
    -   它建立了一個 `IQueryable<Member>` 物件 `query`。這個物件像是一個**查詢產生器**，它內部儲存了一個「運算式樹」，描述了你**打算**對 `Members` 資料表做什麼（例如，先篩選出房東）。

2.  **`if (...) { query = query.Where(...); }`**
    -   接下來的一系列 `if` 判斷式，根據前端傳來的篩選條件，不斷地對 `query` 物件添加 `Where` 條件。
    -   每執行一次 `query.Where(...)`，**仍然沒有執行資料庫查詢**。
    -   它只是在不斷地**修改和擴充**那個運算式樹，告訴產生器：「嘿，除了是房東，我還要名字包含關鍵字，而且還要住在某個城市...」。

3.  **`var totalCount = query.Count();`**
    -   這是**第一次**與資料庫的實際接觸。
    -   `Count()` 是一個**終端操作 (Terminal Operation)**。當它被呼叫時，Entity Framework Core 會檢視 `query` 物件中累積的所有運算式，將它們翻譯成一條最佳化的 `SELECT COUNT(*)` SQL 語句，發送到資料庫去執行，然後只取回一個整數（總筆數）。
    -   **優點**：極其高效。不需要將所有使用者資料拉到伺服器記憶體中再來計算數量。

4.  **`var landlords = query.OrderBy(...).Skip(...).Take(...).ToList();`**
    -   這是**第二次**與資料庫的接觸。
    -   `ToList()` 是另一個**終端操作**。它觸發了第二次查詢。
    -   EF Core 再次將 `query` 的運算式樹，加上新的 `OrderBy`（排序）、`Skip`（跳過幾筆）、`Take`（取幾筆）和 `Select`（塑形）操作，組合成一條**帶有分頁功能**的 SQL `SELECT` 語句。
    -   **優點**：資料庫只會回傳前端需要的**那一頁**的資料（例如 10 筆），並且是已經排好序、轉換好格式的資料。這極大地減少了網路傳輸量和應用程式的記憶體消耗。

### 如果一開始就用 `ToList()` 會發生什麼？

試想如果第一行就寫成：

```csharp
// <<-- 錯誤示範！效能災難！ -->>
var query = _context.Members.Where(m => m.IsLandlord).ToList();
```

-   在這一行，程式會立刻產生一條 `SELECT * FROM Members WHERE IsLandlord = 1` 的 SQL。
-   如果資料庫中有 10 萬筆房東資料，那麼這 10 萬筆資料會**全部被載入到應用程式的記憶體中**，形成一個 `List<Member>`。
-   接下來所有的 `query.Where(...)`、`query.Count()`、`query.Skip(...).Take(...)` 都將在**記憶體中**對這 10 萬筆資料進行操作，而不是在資料庫端。

這會導致：
-   **巨大的記憶體開銷**：瞬間佔用大量伺服器記憶體。
-   **不必要的網路流量**：傳輸了 10 萬筆資料，而使用者可能只需要看前 10 筆。
-   **緩慢的響應速度**：等待大量資料傳輸和載入會非常耗時。
-   **錯誤的總數計算**：後續的篩選是在記憶體中進行的，`totalCount` 會基於篩選後的記憶體列表，而不是資料庫中的完整結果。

### 結論

-   **使用 `IQueryable<T>`**：當你需要**動態組合查詢**、**延遲執行**，並希望將複雜的篩選、排序、分頁等操作交給資料庫去高效完成時，`IQueryable<T>` 是不二之選。它是 LINQ to SQL 或 LINQ to Entities 的核心。

-   **使用 `List<T>` (或呼叫 `.ToList()`)**：當你**確定需要**將查詢結果載入到記憶體中進行後續處理時，才呼叫 `.ToList()`。這一步是「實現」查詢的終點，代表著與資料庫互動的結束和記憶體中操作的開始。
